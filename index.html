<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>MiniCraft – FAST + Inventaire + Drops</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui}
#ui{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.6);color:#fff;z-index:6}
#crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:12px;height:12px;pointer-events:none;z-index:4}
#crosshair::before,#crosshair::after{content:"";position:absolute;background:white}
#crosshair::before{width:12px;height:2px;top:5px}
#crosshair::after{width:2px;height:12px;left:5px}

#hotbar{
  position:fixed;left:50%;bottom:20px;transform:translateX(-50%);
  display:flex;gap:10px;padding:10px;background:rgba(0,0,0,.4);
  border-radius:16px;z-index:4;flex-wrap:wrap;justify-content:center;max-width:92vw
}
.slot{
  width:44px;height:44px;border-radius:12px;border:2px solid rgba(255,255,255,.3);
  display:grid;place-items:center;color:white;position:relative;user-select:none
}
.slot.selected{border-color:white;transform:translateY(-2px)}
.chip{width:26px;height:26px;border-radius:8px;border:1px solid rgba(0,0,0,.25)}
.badge{
  position:absolute;right:6px;bottom:4px;font-size:11px;opacity:.9;
  background:rgba(0,0,0,.45);padding:1px 5px;border-radius:999px
}
.badge.empty{opacity:.45}

#hint{
  position:fixed;left:12px;bottom:12px;color:white;font-size:14px;z-index:4;
  background:rgba(0,0,0,.25);padding:6px 10px;border-radius:12px;max-width:92vw
}
#toast{
  position:fixed;left:50%;bottom:88px;transform:translateX(-50%);
  color:white;z-index:5;background:rgba(0,0,0,.45);
  padding:6px 10px;border-radius:12px;opacity:0;transition:opacity .15s
}
button{padding:10px 16px;border-radius:12px;border:0;cursor:pointer}
small{opacity:.8}
</style>
</head>

<body>
<div id="crosshair"></div>

<div id="ui">
  <div style="text-align:center;max-width:700px;padding:18px">
    <h1 style="margin:0 0 10px">MiniCraft (FAST + Inventaire)</h1>
    <p style="margin:0 0 12px;line-height:1.35">
      Chromebook mode : surface + chunks + inventaire ✅<br>
      <b>WASD</b> bouger · <b>Souris</b> regarder · <b>Espace</b> sauter (1 fois/appui) · <b>Shift</b> courir<br>
      <b>1–7</b> blocs · <b>Clic gauche</b> casser (drop) · <b>Clic droit</b> poser (consomme)
    </p>
    <button id="start">Jouer</button><br>
    <small>(Tu ramasses les drops en marchant dessus.)</small>
  </div>
</div>

<div id="hotbar"></div>
<div id="toast"></div>
<div id="hint">
  Bloc : <span id="blockName">Herbe</span> · Temps: <span id="tod">Jour</span> ·
  Chunk: <span id="chunkInfo">0,0</span> · Biome: <span id="biomeInfo">Plaine</span>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

/* ---------- DOM ---------- */
const ui = document.getElementById("ui");
const startBtn = document.getElementById("start");
const hotbar = document.getElementById("hotbar");
const blockNameEl = document.getElementById("blockName");
const todEl = document.getElementById("tod");
const chunkInfoEl = document.getElementById("chunkInfo");
const biomeInfoEl = document.getElementById("biomeInfo");
const toastEl = document.getElementById("toast");

/* ---------- SCÈNE ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const BASE_FOV = 75;
const SPRINT_FOV = 86;
const FOV_SPEED = 10;
let currentFov = BASE_FOV;

const camera = new THREE.PerspectiveCamera(BASE_FOV, innerWidth/innerHeight, 0.1, 500);
camera.position.set(8, 25, 18);

const renderer = new THREE.WebGLRenderer({antialias:false, powerPreference:"low-power"});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(1); // ✅ Chromebook
document.body.appendChild(renderer.domElement);

/* ---------- LUMIÈRES ---------- */
const sun = new THREE.DirectionalLight(0xffffff, 1.0);
scene.add(sun);
const ambient = new THREE.AmbientLight(0xffffff, 0.38);
scene.add(ambient);
const sunBall = new THREE.Mesh(
  new THREE.SphereGeometry(1.0, 12, 12),
  new THREE.MeshBasicMaterial({ color: 0xfff1a8 })
);
scene.add(sunBall);

/* ---------- BLOCS ---------- */
const BLOCKS = [
  {name:"Herbe",  color:0x4caf50}, // 0
  {name:"Terre",  color:0x7a5230}, // 1
  {name:"Pierre", color:0x9e9e9e}, // 2
  {name:"Bois",   color:0x8d6e63}, // 3
  {name:"Sable",  color:0xd8c38a}, // 4
  {name:"Neige",  color:0xf5f7ff}, // 5
  {name:"Cactus", color:0x2e8b57}, // 6
];
let selectedBlock = 0;

const blockGeo = new THREE.BoxGeometry(1,1,1);
const dropGeo = new THREE.BoxGeometry(0.35,0.35,0.35);

const world = new Map();     // "x,y,z" -> mesh
const overrides = new Map(); // "x,y,z" -> number|null
const key = (x,y,z)=>`${x},${y},${z}`;

function hasBlockAt(wx, wy, wz){
  const bx = Math.floor(wx);
  const by = Math.floor(wy);
  const bz = Math.floor(wz);
  return world.has(`${bx},${by},${bz}`);
}
function addBlockMesh(x,y,z,type){
  const k = key(x,y,z);
  if(world.has(k)) return;
  const mat = new THREE.MeshLambertMaterial({color: BLOCKS[type].color});
  const mesh = new THREE.Mesh(blockGeo, mat);
  mesh.position.set(x+0.5, y+0.5, z+0.5);
  mesh.userData = {x,y,z,type, isMob:false};
  scene.add(mesh);
  world.set(k, mesh);
}
function removeBlockMesh(x,y,z){
  const k = key(x,y,z);
  const mesh = world.get(k);
  if(!mesh) return;
  scene.remove(mesh);
  mesh.geometry.dispose();
  mesh.material.dispose();
  world.delete(k);
}

/* ---------- INVENTAIRE ---------- */
const inv = new Array(BLOCKS.length).fill(0);
// petit “starter kit” pour pouvoir jouer direct
inv[0]=40; inv[1]=40; inv[2]=30; inv[3]=20; inv[4]=30; inv[5]=10; inv[6]=5;

function toast(msg){
  toastEl.textContent = msg;
  toastEl.style.opacity = "1";
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>toastEl.style.opacity="0", 850);
}

/* ---------- HOTBAR (avec quantités) ---------- */
function renderHotbar(){
  hotbar.innerHTML = "";
  BLOCKS.forEach((b,i)=>{
    const slot = document.createElement("div");
    slot.className = "slot" + (i===selectedBlock ? " selected" : "");
    const chip = document.createElement("div");
    chip.className = "chip";
    chip.style.background = "#" + b.color.toString(16).padStart(6,"0");

    const badge = document.createElement("div");
    badge.className = "badge" + (inv( inv[i]===0 ) ? " empty" : "");
    badge.textContent = inv[i];

    slot.appendChild(chip);
    slot.appendChild(badge);
    hotbar.appendChild(slot);
  });
  blockNameEl.textContent = BLOCKS[selectedBlock].name;
}
function updateHotbarCounts(){
  const slots = hotbar.querySelectorAll(".slot");
  slots.forEach((slot,i)=>{
    const badge = slot.querySelector(".badge");
    badge.textContent = inv[i];
    badge.classList.toggle("empty", inv[i]===0);
  });
  blockNameEl.textContent = BLOCKS[selectedBlock].name;
}
function R(x){ return x; } // mini helper (évite un warning si tu copies/colles)
renderHotbar();

/* ---------- CONTROLES ---------- */
let yaw=0, pitch=0, locked=false;
const keys = new Set();
let spaceDown = false;
let jumpQueued = false;

startBtn.addEventListener("click", ()=> renderer.domElement.requestPointerLock());
renderer.domElement.addEventListener("click", ()=> { if(!locked) renderer.domElement.requestPointerLock(); });

document.addEventListener("pointerlockchange", ()=>{
  locked = document.pointerLockElement === renderer.domElement;
  ui.style.display = locked ? "none" : "grid";
});

addEventListener("mousemove", (e)=>{
  if(!locked) return;
  yaw   -= e.movementX * 0.0022;
  pitch -= e.movementY * 0.0022;
  pitch = Math.max(-1.55, Math.min(1.55, pitch));
});

addEventListener("keydown", (e)=>{
  keys.add(e.code);

  if(e.code === "Space" && !e.repeat){
    if(!spaceDown){
      spaceDown = true;
      jumpQueued = true;
    }
  }

  if(e.code === "KeyN" && !e.repeat){
    dayCycleEnabled = !dayCycleEnabled;
  }

  if(e.code.startsWith("Digit")){
    const n = Number(e.code.replace("Digit","")) - 1;
    if(n>=0 && n<BLOCKS.length){
      selectedBlock = n;
      renderHotbar();
    }
  }
});

addEventListener("keyup", (e)=>{
  keys.delete(e.code);
  if(e.code === "Space") spaceDown = false;
});

/* ---------- RAYCAST + OUTLINE ---------- */
const raycaster = new THREE.Raycaster();
addEventListener("contextmenu", e=>e.preventDefault());

const outline = new THREE.BoxHelper(new THREE.Mesh(blockGeo), 0xffffff);
outline.visible = false;
scene.add(outline);

function getHit(){
  raycaster.setFromCamera({x:0,y:0}, camera);
  return raycaster.intersectObjects([...world.values()], false);
}

function canPlaceAt(x,y,z){
  const px = camera.position.x;
  const py = camera.position.y;
  const pz = camera.position.z;
  const dx = (x+0.5) - px;
  const dz = (z+0.5) - pz;
  const closeXZ = (dx*dx + dz*dz) < 0.7*0.7;
  const closeY = Math.abs((y+0.9) - (py-1.0)) < 1.8;
  return !(closeXZ && closeY);
}

/* ---------- DROPS ---------- */
const drops = []; // {mesh, type, vy, spin, cooldown}
const DROP_GRAV = -16;

function spawnDrop(type, x, y, z){
  const mat = new THREE.MeshLambertMaterial({color: BLOCKS[type].color});
  const m = new THREE.Mesh(dropGeo, mat);
  m.position.set(x+0.5, y+0.75, z+0.5);
  scene.add(m);
  drops.push({
    mesh:m,
    type,
    vy: 1.2 + Math.random()*0.8,
    spin: (Math.random()*2-1)*2.0,
    cooldown: 0.25
  });
}

function removeDrop(d){
  scene.remove(d.mesh);
  d.mesh.geometry.dispose();
  d.mesh.material.dispose();
}

/* ---------- CHUNKS + BIOMES (FAST) ---------- */
const CHUNK_SIZE = 12;
const RENDER_DISTANCE = 1; // 9 chunks
const chunks = new Map();
const chunkKey = (cx,cz)=>`${cx},${cz}`;
const worldToChunk = (x)=>Math.floor(x / CHUNK_SIZE);

const SEED = 1337;
function hash2(x,z){
  const n = (x*73856093) ^ (z*19349663) ^ SEED;
  return ((n >>> 0) % 100000) / 100000;
}
function noise2(x,z,scale){
  const s = scale;
  const a = Math.sin((x+SEED)*s) + Math.cos((z-SEED)*s);
  const b = Math.sin((x+z)*s*0.7) * 0.6;
  const c = (hash2(Math.floor(x*0.7), Math.floor(z*0.7)) - 0.5) * 0.8;
  return (a*0.55 + b + c);
}
function clamp01(t){ return Math.max(0, Math.min(1, t)); }
function lerp(a,b,t){ return a + (b-a)*t; }

function biomeAt(x,z){
  const temp  = clamp01(0.5 + noise2(x,z,0.02)*0.22);
  const humid = clamp01(0.5 + noise2(x+1000,z-1000,0.02)*0.22);
  const elev  = noise2(x-500,z+500,0.015);
  const mountain = clamp01((elev - 0.35) * 1.6);

  if(mountain > 0.6) return { name:"Montagnes", top:2, filler:2, dunes:0, cactus:0 };
  if(temp < 0.33)    return { name:"Neige",     top:5, filler:1, dunes:0, cactus:0 };
  if(temp > 0.66 && humid < 0.42)
    return { name:"Désert",    top:4, filler:4, dunes:1, cactus:0.02 };
  if(humid > 0.62)   return { name:"Forêt",     top:0, filler:1, dunes:0, cactus:0 };
  return              { name:"Plaine",    top:0, filler:1, dunes:0, cactus:0 };
}

function heightAt(x,z){
  const b = biomeAt(x,z);
  const base = noise2(x,z,0.03)*3 + noise2(x,z,0.012)*6;

  let dune = 0;
  if(b.dunes){
    dune = (Math.sin((x+SEED)*0.35) + Math.cos((z-SEED)*0.35)) * 1.2
         + noise2(x,z,0.18) * 1.0;
    dune *= 1.2;
  }

  const raw = 8 + base + dune + (hash2(x,z)-0.5)*0.8;
  const h = Math.floor(lerp(3, 16, clamp01((raw+20)/40)));
  return Math.max(2, h);
}

// Surface only : y=h (top) et y=h-1 (filler)
function generateChunk(cx, cz){
  const ck = chunkKey(cx,cz);
  if(chunks.has(ck)) return;

  const blocks = [];
  const startX = cx * CHUNK_SIZE;
  const startZ = cz * CHUNK_SIZE;

  for(let lx=0; lx<CHUNK_SIZE; lx++){
    for(let lz=0; lz<CHUNK_SIZE; lz++){
      const x = startX + lx;
      const z = startZ + lz;

      const b = biomeAt(x,z);
      const h = heightAt(x,z);

      for(const y of [h, h-1]){
        if(y < 0) continue;
        const kk = key(x,y,z);

        if(overrides.has(kk)){
          const ov = overrides.get(kk);
          if(ov === null) continue;
          addBlockMesh(x,y,z,ov);
          blocks.push(kk);
          continue;
        }

        const t = (y === h) ? b.top : b.filler;
        addBlockMesh(x,y,z,t);
        blocks.push(kk);
      }

      // cactus léger (désert)
      if(b.name === "Désert"){
        const r = hash2(x*7+91, z*7-37);
        if(r < b.cactus){
          const ch = 2 + Math.floor(hash2(x*13-5, z*13+9) * 2); // 2..3
          for(let yy=h+1; yy<=h+ch; yy++){
            const kk = key(x,yy,z);
            if(overrides.get(kk) === null) continue;
            addBlockMesh(x,yy,z,6);
            blocks.push(kk);
          }
        }
      }
    }
  }

  chunks.set(ck, { blocks });
}

function unloadChunk(cx, cz){
  const ck = chunkKey(cx,cz);
  const ch = chunks.get(ck);
  if(!ch) return;
  for(const bk of ch.blocks){
    const [sx,sy,sz] = bk.split(",").map(Number);
    removeBlockMesh(sx,sy,sz);
  }
  chunks.delete(ck);
}

let lastCX=null, lastCZ=null;
function updateChunks(force=false){
  const cx = worldToChunk(camera.position.x);
  const cz = worldToChunk(camera.position.z);
  if(!force && cx===lastCX && cz===lastCZ) return;
  lastCX=cx; lastCZ=cz;

  const needed = new Set();
  for(let dx=-RENDER_DISTANCE; dx<=RENDER_DISTANCE; dx++){
    for(let dz=-RENDER_DISTANCE; dz<=RENDER_DISTANCE; dz++){
      const ncx=cx+dx, ncz=cz+dz;
      const k = chunkKey(ncx,ncz);
      needed.add(k);
      generateChunk(ncx,ncz);
    }
  }
  for(const k of chunks.keys()){
    if(!needed.has(k)){
      const [ccx,ccz]=k.split(",").map(Number);
      unloadChunk(ccx,ccz);
    }
  }

  chunkInfoEl.textContent = `${cx},${cz}`;
  biomeInfoEl.textContent = biomeAt(Math.floor(camera.position.x), Math.floor(camera.position.z)).name;
}

/* ---------- INTERACTIONS (casser/poser) ---------- */
addEventListener("mousedown", (e)=>{
  if(!locked) return;
  const hits = getHit();
  if(!hits.length) return;

  const hit = hits[0];
  const obj = hit.object;
  const b = obj.userData;

  if(e.button===0){
    // casser => drop du type
    const t = b.type ?? 0;
    overrides.set(key(b.x,b.y,b.z), null);
    removeBlockMesh(b.x,b.y,b.z);
    spawnDrop(t, b.x, b.y, b.z);

  } else if(e.button===2){
    const n = hit.face?.normal;
    if(!n) return;

    const nx = b.x + Math.round(n.x);
    const ny = b.y + Math.round(n.y);
    const nz = b.z + Math.round(n.z);

    if(!canPlaceAt(nx,ny,nz)) return;

    // inventaire : il faut avoir au moins 1
    if(inv[selectedBlock] <= 0){
      toast("❌ Plus de " + BLOCKS[selectedBlock].name);
      return;
    }

    inv[selectedBlock] -= 1;
    updateHotbarCounts();

    overrides.set(key(nx,ny,nz), selectedBlock);
    addBlockMesh(nx,ny,nz,selectedBlock);
  }
});

/* ---------- JOUR / NUIT ---------- */
let dayCycleEnabled = true;
let timeOfDay = 0.15;
const DAY_SECONDS = 60;
function updateDayNight(dt){
  if(dayCycleEnabled) timeOfDay = (timeOfDay + dt / DAY_SECONDS) % 1;
  const angle = timeOfDay * Math.PI * 2;

  const sunY = Math.sin(angle);
  const sunHeight = clamp01((sunY + 0.1) / 1.1);

  const radius = 55;
  sun.position.set(Math.cos(angle)*radius, lerp(-10, 45, sunHeight), Math.sin(angle)*radius);
  sunBall.position.copy(sun.position);

  sun.intensity = lerp(0.05, 1.0, sunHeight);
  ambient.intensity = lerp(0.08, 0.42, sunHeight);

  const SKY_DAY = new THREE.Color(0x87ceeb);
  const SKY_SUNSET = new THREE.Color(0xff8a4c);
  const SKY_NIGHT = new THREE.Color(0x050814);

  const sunsetFactor = clamp01(1 - Math.abs(sunY) * 3);
  const nightFactor = clamp01(1 - sunHeight);

  scene.background = SKY_DAY.clone().lerp(SKY_SUNSET, sunsetFactor).lerp(SKY_NIGHT, nightFactor*0.9);

  let label="Jour";
  if(sunHeight < 0.15) label="Nuit";
  else if(sunsetFactor > 0.35) label="Coucher/Lever";
  todEl.textContent = dayCycleEnabled ? label : (label + " (pause)");
}

/* ---------- PHYSIQUE JOUEUR ---------- */
let velocityY = 0;
const GRAVITY = -22;
const JUMP_FORCE = 8.5;
const PLAYER_HEIGHT = 1.8;
const EPS = 0.001;

function feetY(y){ return y - PLAYER_HEIGHT; }
function groundBlockYAt(playerY){ return Math.floor(feetY(playerY) - EPS); }
function isSolidUnder(playerY){
  const by = groundBlockYAt(playerY);
  return hasBlockAt(camera.position.x, by, camera.position.z);
}
function snapToGround(playerY){
  const by = groundBlockYAt(playerY);
  return (by + 1) + PLAYER_HEIGHT;
}

/* ---------- BOOT ---------- */
updateChunks(true);
{
  const sx = Math.floor(camera.position.x);
  const sz = Math.floor(camera.position.z);
  const h = heightAt(sx,sz);
  camera.position.y = h + 1 + PLAYER_HEIGHT;
}

/* ---------- LOOP ---------- */
const clock = new THREE.Clock();
let chunkTimer = 0;

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);

  chunkTimer += dt;
  if(chunkTimer > 0.4){
    chunkTimer = 0;
    updateChunks(false);
  }

  updateDayNight(dt);

  // sprint + FOV
  const sprinting = keys.has("ShiftLeft") || keys.has("ShiftRight");
  const targetFov = sprinting ? SPRINT_FOV : BASE_FOV;
  currentFov = currentFov + (targetFov - currentFov) * Math.min(1, FOV_SPEED * dt);
  if (Math.abs(camera.fov - currentFov) > 0.001) {
    camera.fov = currentFov;
    camera.updateProjectionMatrix();
  }

  camera.rotation.set(pitch, yaw, 0, "YXZ");

  // mouvement
  const forward = new THREE.Vector3();
  camera.getWorldDirection(forward);
  forward.y = 0; forward.normalize();
  const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0));

  const speed = sprinting ? 7 : 4.5;

  let move = new THREE.Vector3();
  if(keys.has("KeyW")) move.add(forward);
  if(keys.has("KeyS")) move.sub(forward);
  if(keys.has("KeyA")) move.sub(right);
  if(keys.has("KeyD")) move.add(right);
  if(move.lengthSq()>0) move.normalize().multiplyScalar(speed * dt);

  const nextX = camera.position.x + move.x;
  const nextZ = camera.position.z + move.z;

  if(!hasBlockAt(nextX, camera.position.y - 0.2, camera.position.z) &&
     !hasBlockAt(nextX, camera.position.y - 1.2, camera.position.z)){
    camera.position.x = nextX;
  }
  if(!hasBlockAt(camera.position.x, camera.position.y - 0.2, nextZ) &&
     !hasBlockAt(camera.position.x, camera.position.y - 1.2, nextZ)){
    camera.position.z = nextZ;
  }

  // gravité joueur
  velocityY += GRAVITY * dt;
  let newY = camera.position.y + velocityY * dt;

  if(velocityY <= 0 && isSolidUnder(newY)){
    newY = snapToGround(newY);
    velocityY = 0;
  }
  if(velocityY > 0 && hasBlockAt(camera.position.x, newY - 0.1, camera.position.z)){
    velocityY = 0;
  }
  camera.position.y = newY;

  const onGround = isSolidUnder(camera.position.y);
  if(onGround && jumpQueued) velocityY = JUMP_FORCE;
  jumpQueued = false;

  // respawn
  if(camera.position.y < -20){
    const sx = Math.floor(camera.position.x);
    const sz = Math.floor(camera.position.z);
    const h = heightAt(sx,sz);
    camera.position.set(sx+0.5, h + 1 + PLAYER_HEIGHT, sz+0.5);
    velocityY = 0;
  }

  // update drops (gravité + ramassage)
  for(let i=drops.length-1; i>=0; i--){
    const d = drops[i];
    d.cooldown = Math.max(0, d.cooldown - dt);

    d.vy += DROP_GRAV * dt;
    d.mesh.position.y += d.vy * dt;

    // collision sol simple
    const underY = Math.floor(d.mesh.position.y - 0.2);
    if(hasBlockAt(d.mesh.position.x, underY, d.mesh.position.z)){
      d.mesh.position.y = underY + 1.0;
      d.vy = 0;
    }

    d.mesh.rotation.y += d.spin * dt;
    d.mesh.rotation.x += (d.spin*0.6) * dt;

    // ramassage si proche
    const dx = d.mesh.position.x - camera.position.x;
    const dy = (d.mesh.position.y - 0.6) - (camera.position.y - 1.0);
    const dz = d.mesh.position.z - camera.position.z;
    const dist = Math.hypot(dx,dy,dz);

    if(d.cooldown === 0 && dist < 1.25){
      inv[d.type] = Math.min(999, inv[d.type] + 1);
      updateHotbarCounts();
      toast("+" + BLOCKS[d.type].name);
      removeDrop(d);
      drops.splice(i,1);
    }
  }

  // outline
  const hits = getHit();
  if(hits.length){
    outline.visible = true;
    outline.setFromObject(hits[0].object);
  } else outline.visible = false;

  renderer.render(scene, camera);
}
animate();

addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
